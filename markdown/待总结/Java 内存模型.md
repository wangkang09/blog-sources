[TOC]

## Java 内存模型（Java Memory Model）

### 1 什么是 JMM

- 内存模型可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。不同架构的物理机的内存模型可能不一样
- Java 内存模型（JMM）是 JVM 自己的内存模型，是 **JVM** 用来**屏蔽底层硬件与操作系统**的**内存访问差异** 的中间层模型

- JMM 主要目标：定义程序中各个变量的访问规则。即 JVM 如何从内存中存取变量的底层细节 

### 2 可用在什么地方

- 所有使用 JVM 虚拟机的编程语言中

### 3 为什么要用 JMM

- 为了实现 Write Once Run AnyWhere 的功能

### 4 JMM 核心组成

#### 4.1 主内存与工作内存

- 这里所说的主内存和工作内存**都仅仅是虚拟机内存的一部分**

##### 4.1.1 主内存

- **所有变量都存储在主内存中**，可与物理硬件中的主内存类比，但不相等

##### 4.1.2 工作内存

- **每个线程都有自己的工作内存**，可与 CPU 高速缓存类比，但不相等

- 工作内存中保存了该线程使用到的变量的主内存**副本拷贝**（不是完全拷贝，只是部分拷贝，如引用、某个字段）

- 线程对变量的**所有操作都在工作内存中进行**，不能直接读写主内存中的变量

- #### **不同线程直接无法直接访问对方工作内存**，必须通过主内存来间接访问

##### 4.1.3 并不恰当的对应关系

- 主内存对应于 Java 堆中的对象实例数据部分（堆中还保存着对象的其它信息，如 Mark Word 码、GC标志、GC 年龄、同步锁等信息）
- 工作内存对应于虚拟机栈中的部分区域
- 主内存对应于物理硬件的内存
- 工作内存对应于高速缓存（为了获取更快的运行速度，因为程序运行主要访问读写的是工作内存）

#### 4.2 内存间如何交互

工作内存、主内存间的交互可以通过以下8中操作来定义

##### 4.2.1 八个操作的定义

- lock：作用于主内存变量，把一个变量标识为线程独占状态
- unlock：作用于主内存变量，解除变量的线程独占状态，解除线程必须是独占线程
- read：作用于主内存变量，把一个变量的值从主内存拷贝到工作**内存中**，以便随后的 load 操作（放入主内存）
- load：作用于工作内存变量，吧 read 操作从主内存中得到的变量值，**放入工作内存的变量副本中**（工作内存变量赋值）
- use：作用于工作内存变量，把工作内存中的变量值传递给执行引擎（是虚拟机栈吗？），当 JVM 遇到**使用变量的字节码指令**时，执行这个操作
- assign：作用于工作内存变量，把一个从执行引擎中收到的值赋给工作内存的变量，当 JVM 遇到**给变量赋值的字节码指令时**，执行这个操作
- store：作用于工作内存变量，把工作内存中的变量值传输到主内存中，以便随后的 write 操作
- write：作用于主内存变量，吧 store 从工作内存中得到的变量值，放入主内存的变量中

##### 4.2.2 八个操作遵循的规则

- 不允许 read和load、store和write操作之一单独出现（但这两个操作可以不是连续执行的）
- 不允许一个线程丢弃它最近的 assign 操作（变量在工作内存中改变之后，必须同步回主内存）
- 不允许一个线程无原因的（没有发生assign操作，即变量没有修改）把数据从工作内存同步回主内存
- 一个新的变量只能在主内存中诞生
- 一个变量同一时刻只允许一个线程对其进行 lock 操作，可以重入
- 对一个变量的unlock 操作必须出现在此变量出现 lock 操作之后（不能单独的对一变量做 unlock 操作）
- 一个变量在执行 unlock 之前，必须先把此变量同步回主内存

#### 4.3 volatile 关键字

- volatile 关键字是 JVM 提供的最轻量级的同步机制
- **提供可见性**
  - 改变 volatile 修饰的变量的值时，会立即执行  store、write操作，将值从工作内存刷新到主内存，使得值的变化对其它线程实时可见
  - 普通变量执行 assign 操作后，不一定会立即执行 store、write操作（但肯定要执行），所有其它线程不可见
- **提供有序性**（禁止指令重排）
  - volatile 修饰的变量赋值后会加一个内存屏障
  - 这个内存屏障使得指令重排序是不能将内存屏障后面的指令重排序到内存屏障之前
  - 从而提供了有序性

#### 4.4 原子性、可见性、有序性

**原子性：**

- 一个操作流程是中的所有子过程一个整体，要么全部完成，要么全部回退

- 基本类型数据的访问读写是具备原子性的
- **synchronized 关键字**修饰的代码块具有**原子性**，对应的字节码指令为 monitorenter 和 monitorexit

**可见性：**

- 一个线程修改了共享变量的值，其它线程能够立即得知这个修改
- 除 **volatile 关键字可以保证可见性外**，synchronized 和 final 关键字也可以保证
  - **synchronized 可见性**是由 unlock 操作之间必须把变量值同步会主内存中规则获得
  - final 具有可见性，但不具备有序性，所以和并发没有关联

**有序性：**

- 一段代码具有有序性，说明这段代码的相对位置是固定的，即原来在这段代码之前的代码不会被指令重排到这段代码之后，同理这段代码之后的代码，不会被重排到之前
- **volatile 和 synchronized 关键字具有有序性**

#### 4.5 先行发生原则 - happens-before

- 先行发生原则可以保证有序性

- 如果某个代码块符合先行发生原则（JVM 来判断是否符合），那么这个代码块就是有序的，JVM 不会对其重排序

```java
//这一代码块就符合先行发生原则，JVM 不会将 i = 2 重排到 j = i 之前
//这一代码块是有序执行的
int i = 1;
int j = i;
i = 2;
```

